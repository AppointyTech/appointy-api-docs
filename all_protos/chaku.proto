syntax = "proto3";

package chaku;

import "google/protobuf/descriptor.proto";

option go_package = "go.saastack.io/chaku/validate";

// Chaku constraints applied at the field level
extend google.protobuf.FieldOptions {
    // Constraints will define field level constraints
    FieldConstraints constraints = 99999;
}

// Chaku constraints applied at the message level
extend google.protobuf.MessageOptions {
    // Root is the most important option, in the complete proto file. It
    // is used to describe the main root message in the tree structure of
    // the proto file, (tree structure describes the working flow and the
    // dependency structure in the proto file). At least one root message
    // is required in file, that is not specified as descriptor type, to
    // describe the root tree structure, for which operations are required.
    bool root = 99999;

    // Prefix is a required option in all messages, it is used as prefix
    // in the generated UUID of the message. If not specified in message
    // the first three character of the message name is taken as prefix.
    string prefix = 100000;

    // To Flat is used to set a message as a flat object, which will be
    // flatten where-ever it is used, into its parent object.
    // A root object cannot be a flat object
    bool to_flat = 99998;

    // Hard Delete is used to hard delete the message object instead of
    // default soft delete functionality
    bool hard_delete = 99997;

    // Limit Multiplier for sql limit applying in list, only to be used
    // in root object
    int64 limit_multiplier = 99933;

    // Raw Indices for the sql indices to be provided in the tables, will not
    // work on flat messages
    repeated RawIndex raw_indices = 99932;
}

// Chaku constraints applied at the file level
extend google.protobuf.FileOptions {
    // Descriptors is an optional file-option that specifies whether the
    // proto file is a descriptor type or not. A descriptor type proto
    // file is the one that only describes the messages for external use.
    // So, no CRUD operations are required for them, and hence, specifying
    // the root is useless in such files.
    bool descriptors = 99998;

    // Collection is also the optional file-option. It specifies the custom
    // name of the database schema or cluster.
    string collection = 99999;

    // No migration means when migration file is not to be generated by chaku
    bool no_migration = 99997;

    // Idempotent queries to be executed in database from the file. The file path
    // should be relative to the path of the generated file, e.g. pb directory.
    // The file should be a sql extension file, i.e *.sql
    repeated string idempotent_sql_query_file_path = 99996;
}

// FieldConstraints encapsulates all the constraints that can be applied
// to a field in the message. Some of the constraints are enforced based
// on the type of the field and
message FieldConstraints {
    // Json specifies that the field is required to be stored as a 'json'
    // object in the database, directly without any alteration.
    // A map type or an oneof type field are by default marked as `json`.
    bool json = 1;

    // Skip specifies that the field is not required to be stored in the
    // database, if sets true will not be stored in database
    bool skip = 5;

    // Loosely Dependent on root message; can only be applied on message
    // or object typed fields, that are not set to flat
    bool loosely_dependent = 6;

    // Index specifies whether an index is to be created against this field
    // It will only work on native types e.g. bool, string, int, timestamp, etc.
    // (id, parent/p*id) will by default have primary key composite index
    bool index = 7;
}

// RawIndex represent a multi-column or aggregated functional index in postgresql.
// e.g. For the following index query:
// 		CREATE INDEX IF NOT EXISTS coffee_id_name_index ON coffee.coffee (id, name);
// RawIndex will be
//		{"name": "coffee_id_name_index", "lastPart": "id, name"}
// and For the following query:
// 		CREATE INDEX IF NOT EXISTS coffee_company_index ON coffee.coffee (split_part(parent, '/'::text, 2));
// RawIndex will be
//		{"name": "coffee_company_index", "lastPart": "split_part(parent, '/'::text, 2)"}
message RawIndex {
    // Name will represent the unique name of the index, see above example
    string name = 1;
    // Last Part will represent the remaining portion of the query, see above example
    string last_part = 2;
}
